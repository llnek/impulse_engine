!function(t){"use strict";"object"==typeof module&&module&&"object"==typeof module.exports?t=module.exports:"object"==typeof exports&&exports&&(t=exports);t["io.czlab.impulse_engine.core"]=function(){const e=t["io.czlab.mcfud.core"](),i=t["io.czlab.mcfud.math"](),s=t["io.czlab.mcfud.gfx"](),o=t["io.czlab.mcfud.geo2d"](),n=t["io.czlab.mcfud.vec2"](),c=(e.u,e.is);class r{constructor(t,e,i,s){this.m00=t,this.m01=e,this.m10=i,this.m11=s}clone(){return new r(this.m00,this.m01,this.m10,this.m11)}set(t){let e=Math.cos(t),i=Math.sin(t);return this.m00=e,this.m01=-i,this.m10=i,this.m11=e,this}abs(){return new r(Math.abs(this.m00),Math.abs(this.m01),Math.abs(this.m10),Math.abs(this.m11))}axisX(){return n.V2(this.m00,this.m10)}axisY(){return n.V2(this.m01,this.m11)}transpose(){return new r(this.m00,this.m10,this.m01,this.m11)}}r.mul=function(t,e){return c.vec(e)?n.V2(t.m00*e[0]+t.m01*e[1],t.m10*e[0]+t.m11*e[1]):new r(t.m00*e.m00+t.m01*e.m10,t.m00*e.m01+t.m01*e.m11,t.m10*e.m00+t.m11*e.m10,t.m10*e.m01+t.m11*e.m11)};const l={ePoly:100,eCircle:200,M2:r,dt:1/60,gravity:n.V2(0,50)};return t["io.czlab.impulse_engine.shape"](l,e,i),t["io.czlab.impulse_engine.body"](l,e,i),t["io.czlab.impulse_engine.manifold"](l,e,i),t["io.czlab.impulse_engine.collision"](l,e,i),t["io.czlab.impulse_engine.scene"](l,e,i,s,o),l}}(this),function(t){"use strict";"object"==typeof module&&module&&"object"==typeof module.exports?t=module.exports:"object"==typeof exports&&exports&&(t=exports),t["io.czlab.impulse_engine.shape"]=function(e,i,s){const o=t["io.czlab.mcfud.geo2d"](),n=t["io.czlab.mcfud.gfx"](),c=s.Vec2,r=e.M2,l=i.u;class h{constructor(){this.body=null,this.u=new r}isCircular(){return!1}}class u extends h{constructor(t){super(),this.radius=t}isCircular(){return!0}getAABB(){let t=this.body.position[0]+this.radius,e=this.body.position[0]-this.radius,i=this.body.position[1]+this.radius,s=this.body.position[1]-this.radius;return new o.Rect(e,s,t-e,i-s)}clone(){return new u(this.radius)}initialize(){this.computeMass(1)}computeMass(t){let e=this.radius*this.radius;this.body.m=Math.PI*e*t,this.body.I=this.body.m*e,this.body.im=this.body.m?1/this.body.m:0,this.body.iI=this.body.I?1/this.body.I:0}setOrient(t){return this.u.set(t),this}draw(t){t.save(),t.strokeStyle=this.body.rgb,n.drawCircle(t,this.body.position[0],this.body.position[1],this.radius);let e=r.mul(this.u,c.V2(1,0));e=c.vecMul(e,this.radius),e=c.vecAdd(e,this.body.position),t.strokeStyle="green",n.drawLine(t,this.body.position[0],this.body.position[1],e[0],e[1]),t.restore()}getType(){return e.eCircle}}class a extends h{constructor(){super(),this.points=[],this.normals=[]}getAABB(){let t=this._calcPoints(),e=1/0,i=1/0,s=-1/0,n=-1/0;for(let o,c=0;c<t.length;++c)o=t[c],o[0]<e&&(e=o[0]),o[0]>s&&(s=o[0]),o[1]<i&&(i=o[1]),o[1]>n&&(n=o[1]);return new o.Rect(e,i,s-e,n-i)}initialize(){return this.computeMass(1),this}clone(){let t=new a;t.u=this.u.clone();for(let e=0;e<this.points.length;++e)t.points[e]=c.vecClone(this.points[e]),t.normals[e]=c.vecClone(this.normals[e]);return t}computeMass(t){let e=c.V2(),i=0,s=0;const o=1/3,n=this.points.length;for(let t=0;t<n;++t){let r=this.points[t],l=(t+1)%n,h=this.points[l],u=c.vec2Cross(r,h),a=.5*u;i+=a,e=c.vecAdd(e,c.vecMul(c.vecAdd(r,h),a*o)),s+=.25*o*u*(r[0]*r[0]+h[0]*r[0]+h[0]*h[0]+(r[1]*r[1]+h[1]*r[1]+h[1]*h[1]))}e=c.vecMul(e,1/i);for(let t=0;t<n;++t)c.vecSubSelf(this.points[t],e);return this.body.m=t*i,this.body.im=this.body.m?1/this.body.m:0,this.body.I=s*t,this.body.iI=this.body.I?1/this.body.I:0,this}setOrient(t){return this.u.set(t),this}_calcPoints(){let t=[];for(let e=0;e<this.points.length;++e)t.push(c.vecAdd(this.body.position,r.mul(this.u,this.points[e])));return t}draw(t){t.save(),t.strokeStyle=this.body.rgb,n.drawPoints(t,this._calcPoints()),t.restore()}getType(){return e.ePoly}setBox(t,e){return this.normals.length=0,this.points.length=0,this.points[0]=c.V2(-t,-e),this.points[1]=c.V2(t,-e),this.points[2]=c.V2(t,e),this.points[3]=c.V2(-t,e),this.normals[0]=c.V2(0,-1),this.normals[1]=c.V2(1,0),this.normals[2]=c.V2(0,1),this.normals[3]=c.V2(-1,0),this}set(t){let e=t.length;l.assert(e>2&&e<=64);let i=0,o=t[0][0];for(let n,c=1;c<e;++c)n=t[c][0],n>o?(o=n,i=c):s.fuzzyEq(n,o)&&t[c][1]<t[i][1]&&(i=c);let n=new Array(64),r=0,h=i;for(;;){n[r]=h;let o=0;for(let i=1;i<e;++i){if(o===h){o=i;continue}let e=c.vecSub(t[o],t[n[r]]),l=c.vecSub(t[i],t[n[r]]),u=c.vec2Cross(e,l);u<0&&(o=i),s.fuzzyZero(u)&&c.vecLen2(l)>c.vecLen2(e)&&(o=i)}if(++r,h=o,o===i)break}this.normals.length=0,this.points.length=0;for(let e=0;e<r;++e)this.points[e]=t[n[e]].slice();for(let t=0;t<r;++t){let e=(t+1)%r,i=c.vecSub(this.points[e],this.points[t]);l.assert(c.vecLen2(i)>s.EPSILON*s.EPSILON),this.normals[t]=c.vecUnit(c.V2(i[1],-i[0]))}return this}getSupport(t){let e,i=-1/0;for(let s,o,n=0;n<this.points.length;++n)o=this.points[n],s=c.vecDot(o,t),s>i&&(e=o,i=s);return e}}return l.inject(e,{Circle:u,Polygon:a})}}(this),function(t){"use strict";"object"==typeof module&&module&&"object"==typeof module.exports?t=module.exports:"object"==typeof exports&&exports&&(t=exports),t["io.czlab.impulse_engine.body"]=function(t,e,i){const s=i.Vec2,o=e.u;return o.inject(t,{Body:class{constructor(t,e,i){this.shape=t,this.shape.body=this,this.position=s.V2(e,i),this.velocity=s.V2(),this.angularVelocity=0,this.torque=0,this.rgb="blue",this.force=s.V2(),this.staticFriction=.5,this.dynamicFriction=.3,this.restitution=.2,this.orient=o.randFloat(-Math.PI,Math.PI),this.shape.isCircular()&&(this.rgb="magenta"),this.shape.initialize()}applyForce(t){return this.force=s.vecAdd(this.force,t),this}applyImpulse(t,e){return s.vecAddSelf(this.velocity,s.vecMul(t,this.im)),this.angularVelocity+=this.iI*s.vec2Cross(e,t),this}setStatic(){return this.I=0,this.iI=0,this.m=0,this.im=0,this}setOrient(t){return this.orient=t,this.shape.setOrient(t),this}}})}}(this),function(t){"use strict";"object"==typeof module&&module&&"object"==typeof module.exports?t=module.exports:"object"==typeof exports&&exports&&(t=exports),t["io.czlab.impulse_engine.manifold"]=function(t,e,i){const s=i.Vec2,o=e.u;return o.inject(t,{Manifold:class{constructor(t,e){this.A=t,this.B=e,this.penetration=0,this.normal=s.V2(),this.contacts=[s.V2(),s.V2()],this.contact_count=0,this.e=0,this.df=0,this.sf=0}solve(){return t.dispatch(this.A.shape.getType(),this.B.shape.getType()).call(t,this,this.A,this.B),this}initialize(){this.e=Math.min(this.A.restitution,this.B.restitution),this.sf=Math.sqrt(this.A.staticFriction*this.B.staticFriction),this.df=Math.sqrt(this.A.dynamicFriction*this.B.dynamicFriction);for(let e=0;e<this.contact_count;++e){let o=s.vecSub(this.contacts[e],this.A.position),n=s.vecSub(this.contacts[e],this.B.position),c=s.vecAdd(this.B.velocity,s.vec2Cross(this.B.angularVelocity,n));c=s.vecSub(s.vecSub(c,this.A.velocity),s.vec2Cross(this.A.angularVelocity,o)),s.vecLen2(c)<s.vecLen2(s.vecMul(t.gravity,t.dt))+i.EPSILON&&(this.e=0)}return this}applyImpulse(){if(i.fuzzyZero(this.A.im+this.B.im))return this.infiniteMassCorrection(),this;for(let t=0;t<this.contact_count;++t){let e=s.vecSub(this.contacts[t],this.A.position),o=s.vecSub(this.contacts[t],this.B.position),n=s.vecAdd(this.B.velocity,s.vec2Cross(this.B.angularVelocity,o));n=s.vecSub(s.vecSub(n,this.A.velocity),s.vec2Cross(this.A.angularVelocity,e));let c=s.vecDot(n,this.normal);if(c>0)return this;let r=s.vec2Cross(e,this.normal),l=s.vec2Cross(o,this.normal),h=this.A.im+this.B.im+r*r*this.A.iI+l*l*this.B.iI,u=-(1+this.e)*c;u/=h,u/=this.contact_count;let a=s.vecMul(this.normal,u);this.A.applyImpulse(s.vecFlip(a),e),this.B.applyImpulse(a,o),n=s.vecAdd(this.B.velocity,s.vec2Cross(this.B.angularVelocity,o)),n=s.vecSub(s.vecSub(n,this.A.velocity),s.vec2Cross(this.A.angularVelocity,e));let p=s.vecSub(n,s.vecMul(this.normal,s.vecDot(n,this.normal)));p=s.vecUnit(p);let d,m=-s.vecDot(n,p);if(m/=h,m/=this.contact_count,i.fuzzyZero(m))return this;d=Math.abs(m)<u*this.sf?s.vecMul(p,m):s.vecMul(p,-u*this.df),this.A.applyImpulse(s.vecFlip(d),e),this.B.applyImpulse(d,o)}return this}positionalCorrection(){let t=s.vecMul(this.normal,Math.max(this.penetration-.05,0)/(this.A.im+this.B.im)*.4);return s.vecSubSelf(this.A.position,s.vecMul(t,this.A.im)),s.vecAddSelf(this.B.position,s.vecMul(t,this.B.im)),this}infiniteMassCorrection(){return s.vecCopy(this.A.velocity,0,0),s.vecCopy(this.B.velocity,0,0),this}}})}}(this),function(t){"use strict";"object"==typeof module&&module&&"object"==typeof module.exports?t=module.exports:"object"==typeof exports&&exports&&(t=exports),t["io.czlab.impulse_engine.collision"]=function(t,e,i){const s=i.Vec2,o=t.M2,n=e.u,c={};function r(t,e){let i,n=-1/0;for(let c=0;c<t.points.length;++c){let r=t.normals[c],l=t.points[c],h=o.mul(t.u,r),u=e.u.transpose();r=o.mul(u,h);let a=e.getSupport(s.vecFlip(r));l=s.vecAdd(o.mul(t.u,l),t.body.position),s.vecSubSelf(l,e.body.position),l=o.mul(u,l);let p=s.vecDot(r,s.vecSub(a,l));p>n&&(n=p,i=c)}return[n,i]}function l(t,e,i){let o=[i[0],i[1]],c=0,r=s.vecDot(t,i[0])-e,l=s.vecDot(t,i[1])-e;if(r<=0&&(o[c++]=i[0]),l<=0&&(o[c++]=i[1]),r*l<0){let t=r/(r-l);o[c]=s.vecAdd(i[0],s.vecMul(s.vecSub(i[1],i[0]),t)),++c}return i[0]=o[0],i[1]=o[1],n.assert(3!=c),c}return c.dispatch=function(e,i){return e===t.eCircle?i===t.eCircle?this.circleCircle:this.circlePolygon:e===t.ePoly?i===t.eCircle?this.polygonCircle:this.polygonPolygon:void 0},c.circleCircle=function(t,e,o){let n=e.shape,c=o.shape,r=s.vecSub(o.position,e.position),l=s.vecLen2(r),h=n.radius+c.radius;if(l>=h*h)return void(t.contact_count=0);let u=Math.sqrt(l);t.contact_count=1,i.fuzzyZero(u)?(t.penetration=n.radius,t.normal=s.V2(1,0),s.vecSet(t.contacts[0],e.position)):(t.penetration=h-u,t.normal=s.vecDiv(r,u),s.vecSet(t.contacts[0],s.vecAdd(s.vecMul(t.normal,n.radius),e.position)))},c.circlePolygon=function(e,i,n){let c=i.shape,r=n.shape;e.contact_count=0;let l=o.mul(r.u.transpose(),s.vecSub(i.position,n.position)),h=-1/0,u=0;for(let t=0;t<r.points.length;++t){let e=s.vecDot(r.normals[t],s.vecSub(l,r.points[t]));if(e>c.radius)return;e>h&&(h=e,u=t)}let a=r.points[u],p=(u+1)%r.points.length,d=r.points[p];if(h<t.EPSILON)return e.contact_count=1,e.normal=s.vecFlip(o.mul(r.u,r.normals[u])),s.vecSet(e.contacts[0],s.vecAdd(s.vecMul(e.normal,c.radius),i.position)),void(e.penetration=c.radius);let m=s.vecDot(s.vecSub(l,a),s.vecSub(d,a)),v=s.vecDot(s.vecSub(l,d),s.vecSub(a,d));if(e.penetration=c.radius-h,m<=0){if(s.vecDist2(l,a)>c.radius*c.radius)return;e.contact_count=1;let t=s.vecSub(a,l);e.normal=s.vecUnit(o.mul(r.u,t)),s.vecSet(e.contacts[0],s.vecAdd(o.mul(r.u,a),n.position))}else if(v<=0){if(s.vecDist2(l,d)>c.radius*c.radius)return;e.contact_count=1;let t=s.vecSub(d,l);e.normal=s.vecUnit(o.mul(r.u,t)),s.vecSet(e.contacts[0],s.vecAdd(o.mul(r.u,d),n.position))}else{let t=r.normals[u];if(s.vecDot(s.vecSub(l,a),t)>c.radius)return;e.normal=s.vecFlip(o.mul(r.u,t)),s.vecSet(e.contacts[0],s.vecAdd(s.vecMul(e.normal,c.radius),i.position)),e.contact_count=1}},t.polygonCircle=function(t,e,i){this.circlePolygon(t,i,e),s.vecFlipSelf(t.normal)},t.polygonPolygon=function(t,e,n){let c=e.shape,h=n.shape;t.contact_count=0;let[u,a]=r(c,h);if(u>=0)return;let p,d,m,v,[f,b]=r(h,c);if(f>=0)return;i.biasGreater(u,f)?(p=c,d=h,m=a,v=!1):(p=h,d=c,m=b,v=!0);let y=function(t,e,i){let n=t.normals[i];n=o.mul(t.u,n),n=o.mul(e.u.transpose(),n);let c=0,r=1/0;for(let t,i=0;i<e.points.length;++i)t=s.vecDot(n,e.normals[i]),t<r&&(r=t,c=i);let l=s.vecAdd(o.mul(e.u,e.points[c]),e.body.position);return c=(c+1)%e.points.length,[l,s.vecAdd(o.mul(e.u,e.points[c]),e.body.position)]}(p,d,m),g=p.points[m];m=(m+1)%p.points.length;let S=p.points[m];g=s.vecAdd(o.mul(p.u,g),p.body.position),S=s.vecAdd(o.mul(p.u,S),p.body.position);let A=s.vecUnit(s.vecSub(S,g)),M=s.V2(A[1],-A[0]),z=s.vecDot(M,g),x=-s.vecDot(A,g),V=s.vecDot(A,S);if(l(s.vecFlip(A),x,y)<2)return;if(l(A,V,y)<2)return;t.normal=v?s.vecFlip(M):M;let C=0,B=s.vecDot(M,y[0])-z;B<=0?(t.contacts[C]=y[0],t.penetration=-B,++C):t.penetration=0,B=s.vecDot(M,y[1])-z,B<=0&&(t.contacts[C]=y[1],t.penetration+=-B,++C,t.penetration/=C),t.contact_count=C},n.inject(t,c)}}(this),function(t){"use strict";"object"==typeof module&&module&&"object"==typeof module.exports?t=module.exports:"object"==typeof exports&&exports&&(t=exports),t["io.czlab.impulse_engine.scene"]=function(t,e,i,s,o){const n=i.Vec2,c=e.u;function r(e,s){if(i.fuzzyZero(e.im))return;let o=s/2;n.vecAddSelf(e.velocity,n.vecMul(n.vecAdd(n.vecMul(e.force,e.im),t.gravity),o)),e.angularVelocity+=e.torque*e.iI*o}return c.inject(t,{Scene:class{constructor(t,e){this.dt=t,this.bodies=[],this.contacts=[],this.tries=e}step(){this.contacts.length=0;for(let e,s=0;s<this.bodies.length;++s){e=this.bodies[s];for(let o,n,c=s+1;c<this.bodies.length;++c)n=this.bodies[c],i.fuzzyZero(e.im)&&i.fuzzyZero(n.im)||(o=new t.Manifold(e,n).solve(),o.contact_count>0&&this.contacts.push(o))}this.bodies.forEach(t=>r(t,this.dt)),this.contacts.forEach(t=>t.initialize());for(let t=0;t<this.tries;++t)this.contacts.forEach(t=>t.applyImpulse());this.bodies.forEach(t=>function(t,e){i.fuzzyZero(t.im)||(n.vecAddSelf(t.position,n.vecMul(t.velocity,e)),t.orient+=t.angularVelocity*e,t.setOrient(t.orient),r(t,e))}(t,this.dt)),this.contacts.forEach(t=>t.positionalCorrection()),this.bodies.forEach(t=>{n.vecCopy(t.force,0,0),t.torque=0})}render(t){this.bodies.forEach(e=>e.shape.draw(t))}add(e,i,s){let o=new t.Body(e,i,s);return this.bodies.push(o),o}}})}}(this);